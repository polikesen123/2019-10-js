<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    /*
        匹配 test
        捕获 exec 从字符串中获取满足 正则部分的 字符

    */ 
   //exec 捕获的结果  第一项是大正则捕获的内容，第二项及以后 是小分组捕获到的内容
   //第二项就是第一个小分组，第三项就是第二个小分组
   //若字符串中没有任何符合正则的字符串 ，则获取到的结果就是null
//    var reg = /([a-z]+)(\d+)/
//    var str = '珠峰2019zf2020';
//    var res = reg.exec(str);
//    console.log(res);
//    //------------正则的贪婪性
//    //正则的贪婪性 一次性会把满足正则的字符都捕获到
//    //解决正则的贪婪性  ?
//    var str = 'hello珠峰培训2019zf2020'
//    var reg = /\d+/g;
//    console.log(reg.exec(str));//2019
//    console.log(reg.exec(str));//2020
//    console.log(reg.exec(str));//null
    //捕获的懒惰性  只捕获一次 不再捕获其他符合正则的字符
    //通过添加全局修饰符 g 解决 加上g之后 每次捕获时都会更新 lastIndex 这个属性
    //lastIndex属性控制的是下一次开始匹配的起始索引
    //exec 和 test 都会更新lastIndex属性
   var str = 'hello珠峰培训2019zf2020'
   var reg = /(\d+)/g;
   console.log(reg.exec(str));
//    console.log(reg.exec(str));

   var reg = /^a/m
   var str = `abcd\nabd`
   console.log(reg.test(str));


</script>